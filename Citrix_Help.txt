# ====================================================================
# Script: Remove-Extensions-Remote.ps1
# Purpose: Remove Microsoft Store apps remotely with dynamic DISM fallback
# Author: Eric’s cleanup script (final version)
# ====================================================================

$MachineList = "machines.txt"
$Apps = @(
    "Microsoft.Microsoft3DViewer",
    "Microsoft.WebMediaExtensions",
    "Microsoft.VP9VideoExtensions"
)

$Timestamp = Get-Date -Format 'yyyyMMdd_HHmmss'
$LogFile = "$env:USERPROFILE\Desktop\AppxCleanupLog_$Timestamp.txt"

$MaxRetries = 3
$RetryDelaySeconds = 30

# --- Helper: Ping before connecting ---
function Test-HostOnline {
    param([string]$ComputerName)
    return Test-Connection -ComputerName $ComputerName -Count 1 -Quiet -ErrorAction SilentlyContinue
}

# --- Core cleanup function ---
function Remove-AppsRemote {
    param ([string]$ComputerName, [array]$Apps)

    Write-Host "`n=== Processing $ComputerName ===" -ForegroundColor Cyan
    Add-Content -Path $LogFile -Value "`n=== $ComputerName ==="

    try {
        Invoke-Command -ComputerName $ComputerName -ScriptBlock {
            param($Apps)

            $Results = @()

            foreach ($app in $Apps) {
                try {
                    $Status = "Unknown"

                    # Remove per-user instance
                    $pkg = Get-AppxPackage -Name $app -ErrorAction SilentlyContinue
                    if ($pkg) {
                        Remove-AppxPackage -Package $pkg.PackageFullName -ErrorAction SilentlyContinue
                    }

                    # Remove provisioned (future installs)
                    $prov = Get-AppxProvisionedPackage -Online | Where-Object {$_.DisplayName -eq $app}
                    if ($prov) {
                        Remove-AppxProvisionedPackage -Online -PackageName $prov.PackageName -ErrorAction SilentlyContinue
                    }

                    # Verify removal
                    $check = Get-AppxPackage -Name $app -ErrorAction SilentlyContinue
                    if ($check) {
                        # --- DISM fallback ---
                        Write-Output "[$app] Still detected, attempting DISM removal..."
                        $dismList = dism /Online /Get-ProvisionedAppxPackages | Select-String -Pattern $app -Context 0,1
                        $packageName = ($dismList | Where-Object { $_ -match "PackageName" }) -replace ".*PackageName : ", ""

                        if ($packageName) {
                            Write-Output "Found package name: $packageName"
                            $dismOutput = dism /Online /Remove-ProvisionedAppxPackage /PackageName:$packageName 2>&1
                            if ($LASTEXITCODE -eq 0) {
                                $Status = "SUCCESS (removed via DISM)"
                            } else {
                                $errText = ($dismOutput | Select-String -Pattern 'Error').Line
                                $Status = "FAILED after DISM ($errText)"
                            }
                        } else {
                            $Status = "FAILED - DISM package not found"
                        }
                    } else {
                        $Status = "SUCCESS"
                    }
                }
                catch {
                    $Status = "ERROR - $($_.Exception.Message)"
                }

                $Results += "$app : $Status"
            }

            return $Results
        } -ArgumentList $Apps -ErrorAction Stop | ForEach-Object {
            Add-Content -Path $LogFile -Value "$ComputerName - $_"
        }

        Add-Content -Path $LogFile -Value "COMPLETED: $ComputerName`n"
        Write-Host "✔ $ComputerName processed successfully." -ForegroundColor Green
        return $true
    }
    catch {
        $err = "❌ Failed on $ComputerName - $($_.Exception.Message)"
        Write-Host $err -ForegroundColor Red
        Add-Content -Path $LogFile -Value $err
        return $false
    }
}

# --- Main Execution ---
if (Test-Path $MachineList) {
    $Computers = Get-Content $MachineList | Where-Object { $_ -and $_ -notmatch '^#' }

    foreach ($Computer in $Computers) {
        $Attempt = 1
        $Success = $false

        while (-not $Success -and $Attempt -le $MaxRetries) {
            Write-Host "`nAttempt $Attempt of $MaxRetries for $Computer..." -ForegroundColor Yellow

            if (-not (Test-HostOnline -ComputerName $Computer)) {
                $msg = "⚠️  $Computer is offline or unreachable (skipping attempt $Attempt)."
                Write-Host $msg -ForegroundColor DarkYellow
                Add-Content -Path $LogFile -Value $msg
                Start-Sleep -Seconds $RetryDelaySeconds
                $Attempt++
                continue
            }

            $Success = Remove-AppsRemote -ComputerName $Computer -Apps $Apps

            if (-not $Success -and $Attempt -lt $MaxRetries) {
                Write-Host "Retrying $Computer in $RetryDelaySeconds seconds..." -ForegroundColor DarkYellow
                Start-Sleep -Seconds $RetryDelaySeconds
            }

            $Attempt++
        }

        if (-not $Success) {
            $msg = "⚠️  $Computer failed after $MaxRetries attempts."
            Write-Host $msg -ForegroundColor Red
            Add-Content -Path $LogFile -Value $msg
        }
    }

    Write-Host "`n✅ All processing complete. Log saved to:`n$LogFile" -ForegroundColor Green
} else {
    Write-Error "machines.txt not found in current directory."
}
