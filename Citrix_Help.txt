# ====================================================================
# Script: Remove-Extensions-Remote.ps1
# Purpose: Remove specific Microsoft Store apps from multiple PCs
# Author: Eric’s cleanup script
# ====================================================================

# File containing list of target machines (one per line)
$MachineList = "machines.txt"

# Apps to remove
$Apps = @(
    "Microsoft.Microsoft3DViewer",
    "Microsoft.WebMediaExtensions",
    "Microsoft.VP9VideoExtensions"
)

# Log file (timestamped)
$Timestamp = Get-Date -Format 'yyyyMMdd_HHmmss'
$LogFile = "$env:USERPROFILE\Desktop\AppxCleanupLog_$Timestamp.txt"

# Max retries for offline/unreachable machines
$MaxRetries = 3
$RetryDelaySeconds = 30

# Function to remove apps on a remote machine
function Remove-AppsRemote {
    param (
        [string]$ComputerName,
        [array]$Apps
    )

    Write-Host "`n=== Processing $ComputerName ===" -ForegroundColor Cyan
    Add-Content -Path $LogFile -Value "`n=== $ComputerName ==="

    try {
        Invoke-Command -ComputerName $ComputerName -ScriptBlock {
            param($Apps)

            $Results = @()

            foreach ($app in $Apps) {
                $Status = "Unknown"
                try {
                    # Remove Appx packages for all users
                    Get-AppxPackage -AllUsers -Name $app -ErrorAction SilentlyContinue | Remove-AppxPackage -AllUsers -ErrorAction SilentlyContinue

                    # Remove provisioned (future users)
                    Get-AppxProvisionedPackage -Online | Where-Object {$_.DisplayName -eq $app} | Remove-AppxProvisionedPackage -Online -ErrorAction SilentlyContinue

                    # Verify removal
                    $Check = Get-AppxPackage -AllUsers -Name $app -ErrorAction SilentlyContinue
                    if ($Check) {
                        $Status = "FAILED (still detected)"
                    } else {
                        $Status = "SUCCESS"
                    }
                } catch {
                    $Status = "ERROR: $($_.Exception.Message)"
                }
                $Results += "$app : $Status"
            }

            return $Results
        } -ArgumentList ($Apps) -ErrorAction Stop | ForEach-Object {
            Add-Content -Path $LogFile -Value "$ComputerName - $_"
        }

        Add-Content -Path $LogFile -Value "COMPLETED: $ComputerName`n"
        Write-Host "✔ $ComputerName processed successfully." -ForegroundColor Green
        return $true
    }
    catch {
        $errMsg = "❌ Failed on $ComputerName - $($_.Exception.Message)"
        Write-Host $errMsg -ForegroundColor Red
        Add-Content -Path $LogFile -Value $errMsg
        return $false
    }
}

# Main logic
if (Test-Path $MachineList) {
    $Computers = Get-Content $MachineList | Where-Object { $_ -and $_ -notmatch '^#' }

    foreach ($Computer in $Computers) {
        $Attempt = 1
        $Success = $false

        while (-not $Success -and $Attempt -le $MaxRetries) {
            Write-Host "`nAttempt $Attempt of $MaxRetries for $Computer..." -ForegroundColor Yellow
            $Success = Remove-AppsRemote -ComputerName $Computer -Apps $Apps

            if (-not $Success -and $Attempt -lt $MaxRetries) {
                Write-Host "Retrying $Computer in $RetryDelaySeconds seconds..." -ForegroundColor DarkYellow
                Start-Sleep -Seconds $RetryDelaySeconds
            }

            $Attempt++
        }

        if (-not $Success) {
            $msg = "⚠️  $Computer failed after $MaxRetries attempts."
            Write-Host $msg -ForegroundColor Red
            Add-Content -Path $LogFile -Value $msg
        }
    }

    Write-Host "`nAll processing complete. Log saved to:`n$LogFile" -ForegroundColor Yellow
} else {
    Write-Error "machines.txt not found in current directory."
}
