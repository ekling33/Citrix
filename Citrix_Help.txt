# ====================================================================
# Script: Remove-Extensions-Remote.ps1
# Purpose: Remove Microsoft Store apps remotely with fully dynamic DISM fallback
# Author: Eric’s cleanup script (verified version)
# ====================================================================

$MachineList = "machines.txt"
$Apps = @(
    "Microsoft.Microsoft3DViewer",
    "Microsoft.WebMediaExtensions",
    "Microsoft.VP9VideoExtensions"
)

$Timestamp = Get-Date -Format 'yyyyMMdd_HHmmss'
$LogFile = "$env:USERPROFILE\Desktop\AppxCleanupLog_$Timestamp.txt"

$MaxRetries = 3
$RetryDelaySeconds = 30

function Test-HostOnline {
    param([string]$ComputerName)
    return Test-Connection -ComputerName $ComputerName -Count 1 -Quiet -ErrorAction SilentlyContinue
}

function Remove-AppsRemote {
    param ([string]$ComputerName, [array]$Apps)

    Write-Host "`n=== Processing $ComputerName ===" -ForegroundColor Cyan
    Add-Content -Path $LogFile -Value "`n=== $ComputerName ==="

    try {
        Invoke-Command -ComputerName $ComputerName -ScriptBlock {
            param($Apps)

            $Results = @()

            foreach ($app in $Apps) {
                try {
                    $Status = "Unknown"

                    # Remove per-user install
                    $pkg = Get-AppxPackage -Name $app -ErrorAction SilentlyContinue
                    if ($pkg) {
                        Remove-AppxPackage -Package $pkg.PackageFullName -ErrorAction SilentlyContinue
                    }

                    # Remove provisioned instance
                    $prov = Get-AppxProvisionedPackage -Online | Where-Object {$_.DisplayName -eq $app}
                    if ($prov) {
                        Remove-AppxProvisionedPackage -Online -PackageName $prov.PackageName -ErrorAction SilentlyContinue
                    }

                    # Verify
                    $check = Get-AppxPackage -Name $app -ErrorAction SilentlyContinue
                    if ($check) {
                        # --- DISM fallback ---
                        Write-Output "[$app] Still detected, running DISM package query..."

                        $dismOutput = dism /Online /Get-ProvisionedAppxPackages 2>&1
                        $packageName = ($dismOutput | Where-Object {$_ -match "^PackageName"} | Where-Object {$_ -match $app}) -replace "PackageName : ", ""

                        if ($packageName) {
                            Write-Output "Found package name: $packageName"
                            $dismResult = dism /Online /Remove-ProvisionedAppxPackage /PackageName:$packageName 2>&1
                            if ($LASTEXITCODE -eq 0) {
                                $Status = "SUCCESS (removed via DISM)"
                            } else {
                                $errLine = ($dismResult | Select-String -Pattern 'Error' | Select-Object -First 1).Line
                                $Status = "FAILED after DISM ($errLine)"
                            }
                        } else {
                            $Status = "FAILED - DISM package not found"
                        }
                    } else {
                        $Status = "SUCCESS"
                    }
                }
                catch {
                    $Status = "ERROR - $($_.Exception.Message)"
                }

                $Results += "$app : $Status"
            }

            return $Results
        } -ArgumentList $Apps -ErrorAction Stop | ForEach-Object {
            Add-Content -Path $LogFile -Value "$ComputerName - $_"
        }

        Add-Content -Path $LogFile -Value "COMPLETED: $ComputerName`n"
        Write-Host "✔ $ComputerName processed successfully." -ForegroundColor Green
        return $true
    }
    catch {
        $err = "❌ Failed on $ComputerName - $($_.Exception.Message)"
        Write-Host $err -ForegroundColor Red
        Add-Content -Path $LogFile -Value $err
        return $false
    }
}

if (Test-Path $MachineList) {
    $Computers = Get-Content $MachineList | Where-Object {
